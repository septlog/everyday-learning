# let 和 const 命令

## let 命令

### 基本用法

let 声明的变量只在其所在的代码块中有效。

for 循环的计数器，就很适合使用 let 变量。

for 循环还有一个特别之处，就是设置循环变量的部分是一个父作用域，而循环体内部是一个单独的子作用域。

### let 不存在变量提升

var 关键词会发生变量提升，即变量可以在声明之前使用，值为 undefined。

let 命令声明的变量一定要在声明后使用。

### 暂时性死区

``` js
if (true) {

    var tree = 'seed';
    if (true) {
        tree = 'seedling'; // ReferenceError: Cannot access 'tree' before initialization
        let tree;
        tree = 'small tree';
    }
}
console.log(tree); // seed
```

暂时性死区意味着 typeof 不是一个百分百安全的操作。

### 不允许重复声明

因此，不能在函数内部重新声明参数。

## 块级作用域

块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。

内层作用域可以定义外层作用域的同名变量。

### 块级作用域与函数声明

ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域中声明。

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似与 let，在块级作用域之外不可引用。

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就不认为存在块级作用域。

## const 命令

const 声明一个只读的常量，一旦声明，常量的值就不能被改变。

意味着 const 一旦声明变量，就必须**立即**初始化。

const 的作用域与 let 命令相同。不提升，存在 TDZ，不可重复声明。

对于复合类型的数据（主要是数组），变量指向的是内存地址，const 只能保证指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个**对象**声明为常量必须非常小心。

### ES6 声明变量的六种方法

除了 ES5 的两种声明变量的方法：var 命令和 function 命令。ES6 除了添加 let 和 const，还有 import 命令和 class 命令。

## 顶层对象的属性

顶层对象，在浏览器中指的是 window 对象，在 Node 中指的是 global 对象。

ES6 规定，var 和 function 命令声明的全局变量依旧是顶层变量的属性，而 let，const，class 声明的全局变量不属于顶层变量。
